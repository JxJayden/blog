<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  
  <title>代码与胡说</title>
  <meta name="description" content="我与我周旋久，宁作我。" />
  <meta name="keywords" content="hexo,blog,JxJayden,f2e, front-end" />
  <meta name="HandheldFriendly" content="True" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="我与我周旋久，宁作我。">
<meta property="og:type" content="website">
<meta property="og:title" content="代码与胡说">
<meta property="og:url" content="http://blog.jxdjayden.cn/index.html">
<meta property="og:site_name" content="代码与胡说">
<meta property="og:description" content="我与我周旋久，宁作我。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="代码与胡说">
<meta name="twitter:description" content="我与我周旋久，宁作我。">
  
  
    <link rel="icon" href="/favicon.png">
  

	<script src="https://use.typekit.net/eyf3hir.js"></script>
  <script>try{Typekit.load({ async: false });}catch(e){}</script>
  <link rel="stylesheet" href="/style.css">
  <script>
    function setLoadingBarProgress(num) {
      document.getElementById('loading-bar').style.width=num+"%";
    }
  </script>
  

</head>

<body>
  
  <div id="loading-bar-wrapper">
  <div id="loading-bar"></div>
</div>

  <script>setLoadingBarProgress(20)</script>
  
  <div id="site-wrapper">
    
    <header id="header">
	<div id="header-wrapper" class="clearfix">
		<a id="logo" href="/">
			<img src="/images/logo.png" />
			<span id="site-desc">
			  我与我周旋久，宁作我。
      </span>
		</a>
		<button id="site-nav-switch">
	    <span class="icon icon-menu"></span>
	  </button>
	</div>
	<aside id="site-menu">
  	<nav>
  		
        <a href="/" class="nav-home nav">
          Home
        </a>
      
        <a href="/about" class="nav-about nav">
          About
        </a>
      
        <a href="/archives" class="nav-archives nav">
          Archives
        </a>
      
    </nav>
	</aside>
</header>
    <script>setLoadingBarProgress(40);</script>
    
    <main id="main" role="main">
      





<section class="post-list">
	
    <article class="post ">

  
  <h2 class="title">
    <a href="/2017/02/16/node/node-simplereader/">
      node 爬虫后续：爬虫阅读器 for 鬼吹灯
    </a>
  </h2>
  
  <time>
    2月 16, 2017
  </time>
  <section class="content">
	  <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有次无意中看到狼叔（i5ting）的 <a href="https://github.com/i5ting/simplereader">大主宰小说阅读器</a> ，正好那个时候在重新看自己高中时代最喜欢的小说——《鬼吹灯》，本着学习的目的，就有了这个东西。</p>

    
	  <div class="readmore">
      <a href="/2017/02/16/node/node-simplereader/">Read More</a>
    </div>
    
    
    
	  <div class="tags">
      <a class="tag-link" href="/tags/cheerio/">cheerio</a><a class="tag-link" href="/tags/crawler/">crawler</a><a class="tag-link" href="/tags/node/">node</a><a class="tag-link" href="/tags/爬虫/">爬虫</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/2017/02/14/node/node-guichuideng-spider/">
      使用 koa + crawler + cheerio 爬取《鬼吹灯》小说
    </a>
  </h2>
  
  <time>
    2月 14, 2017
  </time>
  <section class="content">
	  <h2 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h2><p>之前看到狼叔写的 <a href="https://github.com/i5ting/simplereader">node-simplereader</a> ，就想仿照着写一个 《鬼吹灯》的同款小说阅读器，但是一直没动手。现在空出时间了，就来试着写写。这篇文章是先写爬虫部分。</p>

    
	  <div class="readmore">
      <a href="/2017/02/14/node/node-guichuideng-spider/">Read More</a>
    </div>
    
    
    
	  <div class="tags">
      <a class="tag-link" href="/tags/cheerio/">cheerio</a><a class="tag-link" href="/tags/crawler/">crawler</a><a class="tag-link" href="/tags/node/">node</a><a class="tag-link" href="/tags/爬虫/">爬虫</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/2017/02/08/ES6/reflect-and-proxy-note/">
      代理与反射笔记
    </a>
  </h2>
  
  <time>
    2月 8, 2017
  </time>
  <section class="content">
	  <p>本文为个人阅读《Understanding ECMAScript 6》所做的记录，以代码片段为主，大家可以直接去看书<a href="https://leanpub.com/understandinges6/read#leanpub-auto-promises-and-asynchronous-programming" target="_blank" rel="external">Understanding ECMAScript 6</a>，<a href="https://sagittarius-rev.gitbooks.io/understanding-ecmascript-6-zh-ver/content/" target="_blank" rel="external">中译版</a>。</p>
<h2 id="代理与反射是什么？"><a href="#代理与反射是什么？" class="headerlink" title="代理与反射是什么？"></a>代理与反射是什么？</h2><blockquote>
<p>通过调用 new Proxy() ，你可以创建一个代理用来替代另一个对象（被称为目标），这个代理对目标对象进行了虚拟，因此该代理与该目标对象表面上可以被当作同一个对象来对待。<br>代理允许你拦截在目标对象上的底层操作，而这原本是 JS 引擎的内部能力。拦截行为使用了一个能够响应特定操作的函数（被称为陷阱）。</p>
</blockquote>
<h2 id="创建一个简单的代理"><a href="#创建一个简单的代理" class="headerlink" title="创建一个简单的代理"></a>创建一个简单的代理</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;&#125;);</div><div class="line"></div><div class="line">proxy.name = <span class="string">"proxy"</span>;</div><div class="line"><span class="built_in">console</span>.log(proxy.name);        <span class="comment">// "proxy"</span></div><div class="line"><span class="built_in">console</span>.log(target.name);       <span class="comment">// "proxy"</span></div><div class="line"></div><div class="line">target.name = <span class="string">"target"</span>;</div><div class="line"><span class="built_in">console</span>.log(proxy.name);        <span class="comment">// "target"</span></div><div class="line"><span class="built_in">console</span>.log(target.name);       <span class="comment">// "target"</span></div></pre></td></tr></table></figure>
<h2 id="使用-set-陷阱函数验证属性值"><a href="#使用-set-陷阱函数验证属性值" class="headerlink" title="使用 set 陷阱函数验证属性值"></a>使用 set 陷阱函数验证属性值</h2><p>假设你想要创建一个对象，并要求其属性值只能是数值，这就意味着该对象的每个新增属性都要被验证，并且在属性值不为数值类型时应当抛出错误。为此你需要定义 set 陷阱函数来重写设置属性值时的默认行为，该陷阱函数能接受四个参数：</p>
<ol>
<li>trapTarget ：将接收属性的对象（即代理的目标对象）；</li>
<li>key ：需要写入的属性的键（字符串类型或符号类型）；</li>
<li>value ：将被写入属性的值；</li>
<li>receiver ：操作发生的对象（通常是代理对象）。<br><code>Reflect.set()</code> 是 set 陷阱函数对应的反射方法，同时也是 set 操作的默认行为。 <code>Reflect.set()</code> 方法与 set 陷阱函数一样，能接受这四个参数，让该方法能在陷阱函数内部被方便使用。</li>
</ol>
<p>例：使用 set 陷阱函数来拦截传入的 value 值，对属性值进行验证。如果属性值不为数字，则抛出异常。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> obj = &#123; name: <span class="string">'proxyObj'</span> &#125;</div><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(obj, &#123;</div><div class="line"></div><div class="line">    set(trapTarget, key, value, receiver) &#123;</div><div class="line">        <span class="keyword">if</span> (!trapTarget.hasOwnProperty(key)) &#123; <span class="comment">// 修改已有的属性则不做限制</span></div><div class="line"></div><div class="line">            <span class="keyword">if</span> (<span class="built_in">isNaN</span>(value)) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Property must be a number.'</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                <span class="built_in">console</span>.log(<span class="string">`set <span class="subst">$&#123;key&#125;</span> =&gt; <span class="subst">$&#123;value&#125;</span>`</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.set(trapTarget, key, value, receiver);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;)</div><div class="line"></div><div class="line">proxy.count = <span class="number">1</span>;</div><div class="line"><span class="built_in">console</span>.log(proxy.count); <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(obj.count); <span class="comment">// 1</span></div><div class="line"></div><div class="line"><span class="comment">// 你可以为 name 赋一个非数值类型的值，因为该属性已经存在</span></div><div class="line">proxy.name = <span class="string">'proxy'</span>;</div><div class="line"><span class="built_in">console</span>.log(proxy.name); <span class="comment">// "proxy"</span></div><div class="line"><span class="built_in">console</span>.log(obj.name); <span class="comment">// "proxy"</span></div><div class="line"></div><div class="line"><span class="comment">// 抛出错误</span></div><div class="line">proxy.anotherName = <span class="string">'proxy'</span>;</div></pre></td></tr></table></figure>
<h2 id="使用-get-陷阱函数进行对象外形验证"><a href="#使用-get-陷阱函数进行对象外形验证" class="headerlink" title="使用 get 陷阱函数进行对象外形验证"></a>使用 get 陷阱函数进行对象外形验证</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</div><div class="line">        get(trapTarget, key, receiver) &#123;</div><div class="line">            <span class="keyword">if</span> (!(key <span class="keyword">in</span> receiver)) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Property "</span> + key + <span class="string">" doesn't exist."</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">return</span> <span class="built_in">Reflect</span>.get(trapTarget, key, receiver);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line"></div><div class="line"><span class="comment">// 添加属性的功能正常</span></div><div class="line">proxy.name = <span class="string">"proxy"</span>;</div><div class="line"><span class="built_in">console</span>.log(proxy.name);            <span class="comment">// "proxy"</span></div><div class="line"></div><div class="line"><span class="comment">// 读取不存在属性会抛出错误</span></div><div class="line"><span class="built_in">console</span>.log(proxy.nme);             <span class="comment">// 抛出错误</span></div></pre></td></tr></table></figure>
<p>使用 in 运算符来判断 receiver 对象上是否已存在对应属性。 receiver 并没有使用 trapTarget ，而是用了 in ，这是因为 receiver 本身就是拥有一个 has 陷阱函数的代理对象，在此处使用 trapTarget 会跳过 has 陷阱函数，并可能给你一个错误的结果。</p>
<h2 id="使用-has-陷阱函数隐藏属性"><a href="#使用-has-陷阱函数隐藏属性" class="headerlink" title="使用 has 陷阱函数隐藏属性"></a>使用 has 陷阱函数隐藏属性</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;</div><div class="line">    value: <span class="number">42</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"value"</span> <span class="keyword">in</span> target);     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">"toString"</span> <span class="keyword">in</span> target);  <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h2 id="原型代理的陷阱函数"><a href="#原型代理的陷阱函数" class="headerlink" title="原型代理的陷阱函数"></a>原型代理的陷阱函数</h2><p>例：通过返回 <code>null</code> 隐藏了代理对象的原型，并且使得该原型不可被修改</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</div><div class="line">    getPrototypeOf(trapTarget) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</div><div class="line">    &#125;,</div><div class="line">    setPrototypeOf(trapTarget, proto) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> targetProto = <span class="built_in">Object</span>.getPrototypeOf(target);</div><div class="line"><span class="keyword">let</span> proxyProto = <span class="built_in">Object</span>.getPrototypeOf(proxy);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(targetProto === <span class="built_in">Object</span>.prototype);      <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(proxyProto === <span class="built_in">Object</span>.prototype);       <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(proxyProto);                            <span class="comment">// null</span></div><div class="line"></div><div class="line"><span class="comment">// 成功</span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(target, &#123;&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 抛出错误</span></div><div class="line"><span class="built_in">Object</span>.setPrototypeOf(proxy, &#123;&#125;);</div></pre></td></tr></table></figure>
<p><strong>Reflect.getPrototypeOf() 与 Reflect.setPrototypeOf() 和 Object.getPrototypeOf() 与 Object.setPrototypeOf() 的区别：</strong></p>
<blockquote>
<p>首先， <code>Object.getPrototypeOf()</code> 与 <code>Object.setPrototypeOf()</code> 属于高级操作，从产生之初便已提供给开发者使用；而 <code>Reflect.getPrototypeOf()</code> 与 <code>Reflect.setPrototypeOf()</code> 属于底层操作，允许开发者访问 <code>[[GetPrototypeOf]]</code> 与 <code>[[SetPrototypeOf]]</code> 这两个原先仅供语言内部使用的操作。 <code>Reflect.getPrototypeOf()</code> 方法是对内部的 <code>[[GetPrototypeOf]]</code> 操作的封装（并附加了一些输入验证），而 <code>Reflect.setPrototypeOf()</code> 方法与 <code>[[SetPrototypeOf]]</code> 操作之间也存在类似的关系。虽然 Object 对象上的同名方法也调用了 <code>[[GetPrototypeOf]]</code> 与 <code>[[SetPrototypeOf]]</code> ，但它们在调用这两个操作之前添加了一些步骤、并检查返回值，以决定如何行动。<br><code>Reflect.getPrototypeOf()</code> 方法在接收到的参数不是一个对象时会抛出错误，而 <code>Object.getPrototypeOf()</code> 则会在操作之前先将参数值转换为一个对象。如果你分别传入一个数值给这两个方法，会得到截然不同的结果：</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> result1 = <span class="built_in">Object</span>.getPrototypeOf(<span class="number">1</span>);</div><div class="line"><span class="built_in">console</span>.log(result1 === <span class="built_in">Number</span>.prototype);  <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="comment">// 抛出错误</span></div><div class="line"><span class="built_in">Reflect</span>.getPrototypeOf(<span class="number">1</span>);</div></pre></td></tr></table></figure>
<blockquote>
<p><code>Reflect.setPrototypeOf()</code> 方法返回一个布尔值用于表示操作是否已成功，成功时返回 <code>true</code> ，而失败时返回 <code>false</code> ；但若 <code>Object.setPrototypeOf()</code> 方法的操作失败，它会抛出错误。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target1 = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> result1 = <span class="built_in">Object</span>.setPrototypeOf(target1, &#123;&#125;);</div><div class="line"><span class="built_in">console</span>.log(result1 === target1);                   <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> target2 = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> result2 = <span class="built_in">Reflect</span>.setPrototypeOf(target2, &#123;&#125;);</div><div class="line"><span class="built_in">console</span>.log(result2 === target2);                   <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(result2);                               <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h2 id="对象可扩展性的陷阱函数"><a href="#对象可扩展性的陷阱函数" class="headerlink" title="对象可扩展性的陷阱函数"></a>对象可扩展性的陷阱函数</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> target = &#123;&#125;;</div><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(target, &#123;</div><div class="line">    isExtensible(trapTarget) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.isExtensible(trapTarget);</div><div class="line">    &#125;,</div><div class="line">    preventExtensions(trapTarget) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.preventExtensions(trapTarget);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(target));       <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(proxy));        <span class="comment">// true</span></div><div class="line"></div><div class="line"><span class="built_in">Object</span>.preventExtensions(proxy);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(target));       <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.isExtensible(proxy));        <span class="comment">// false</span></div></pre></td></tr></table></figure>
<h3 id="可扩展性的重复方法"><a href="#可扩展性的重复方法" class="headerlink" title="可扩展性的重复方法"></a>可扩展性的重复方法</h3><p><code>Object.isExtensible()</code> 方法与 <code>Reflect.isExtensible()</code> 方法几乎一样，只在接收到的参数不是一个对象时才有例外。此时 <code>Object.isExtensible()</code> 总是会返回 <code>false</code> ，而 <code>Reflect.isExtensible()</code> 则会抛出一个错误。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = <span class="built_in">Object</span>.isExtensible(<span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">let</span> b = <span class="built_in">Reflect</span>.isExtensible(<span class="number">2</span>);</div><div class="line">&#125; <span class="keyword">catch</span>(e) &#123;</div><div class="line">    <span class="built_in">console</span>.log(e);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// false</span></div><div class="line"><span class="comment">// TypeError: Reflect.isExtensible called on non-object</span></div></pre></td></tr></table></figure>
<blockquote>
<p><code>Object.preventExtensions()</code> 方法与 <code>Reflect.preventExtensions()</code> 方法也是非常相似的。 <code>Object.preventExtensions()</code> 方法总是将传递给它的参数值作为自身的返回值，即使该参数不是一个对象；而另一方面 <code>Reflect.preventExtensions()</code> 方法则会在参数不是对象时抛出错误。当参数确实是一个对象时， <code>Reflect.preventExtensions()</code> 会在操作成功时返回 true ，否则返回 false 。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> a = <span class="built_in">Object</span>.preventExtensions(<span class="number">2</span>);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a);</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    <span class="keyword">let</span> b = <span class="built_in">Reflect</span>.preventExtensions(<span class="number">2</span>);</div><div class="line">&#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="built_in">console</span>.log(e);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> c = <span class="built_in">Reflect</span>.preventExtensions(&#123;name: <span class="string">'test'</span>&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(c);</div><div class="line"></div><div class="line"><span class="comment">// 2</span></div><div class="line"><span class="comment">// TypeError: Reflect.preventExtensions called on non-object</span></div><div class="line"><span class="comment">// true</span></div></pre></td></tr></table></figure>
<h2 id="属性描述符的陷阱函数"><a href="#属性描述符的陷阱函数" class="headerlink" title="属性描述符的陷阱函数"></a>属性描述符的陷阱函数</h2><h3 id="阻止-Object-defineProperty"><a href="#阻止-Object-defineProperty" class="headerlink" title="阻止 Object.defineProperty()"></a>阻止 Object.defineProperty()</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</div><div class="line">    defineProperty(trapTarget, key, descriptor) &#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">typeof</span> key === <span class="string">"symbol"</span>) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> <span class="built_in">Reflect</span>.defineProperty(trapTarget, key, descriptor);</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">Object</span>.defineProperty(proxy, <span class="string">"name"</span>, &#123;</div><div class="line">    value: <span class="string">"proxy"</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(proxy.name);                    <span class="comment">// "proxy"</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> nameSymbol = <span class="built_in">Symbol</span>(<span class="string">"name"</span>);</div><div class="line"></div><div class="line"><span class="comment">// 抛出错误</span></div><div class="line"><span class="built_in">Object</span>.defineProperty(proxy, nameSymbol, &#123;</div><div class="line">    value: <span class="string">"proxy"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="描述符对象的限制"><a href="#描述符对象的限制" class="headerlink" title="描述符对象的限制"></a>描述符对象的限制</h3><p>任意对象都能作为 <code>Object.defineProperty()</code> 方法的第三个参数；然而传递给 <code>defineProperty</code> 陷阱函数的描述符对象参数，则只有 <code>enumerable</code> 、 <code>configurable</code> 、 <code>value</code> 、 <code>writable</code> 、 <code>get</code> 与 <code>set</code> 这些属性是被许可的。<br><code>getOwnPropertyDescriptor</code> 陷阱函数有一个微小差异，要求返回值必须是 <code>null</code> 、 <code>undefined</code> ，或者是一个对象。如果返回值是一个对象，则只允许该对象拥有 <code>enumerable</code> 、 <code>configurable</code> 、 <code>value</code> 、 <code>writable</code> 、 <code>get</code> 或 <code>set</code> 这些自有属性。</p>


    
    
    
	  <div class="tags">
      <a class="tag-link" href="/tags/ES6/">ES6</a><a class="tag-link" href="/tags/JavaScript/">JavaScript</a><a class="tag-link" href="/tags/proxy/">proxy</a><a class="tag-link" href="/tags/reflect/">reflect</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/2017/02/08/ES6/Promises-and-Asynchronous-Programming-note/">
      Promise 与异步编程笔记
    </a>
  </h2>
  
  <time>
    2月 8, 2017
  </time>
  <section class="content">
	  <p>本文为个人阅读《Understanding ECMAScript 6》所做的记录，以代码片段为主，大家可以直接去看书<a href="https://leanpub.com/understandinges6/read#leanpub-auto-promises-and-asynchronous-programming" target="_blank" rel="external">Understanding ECMAScript 6</a>，<a href="https://sagittarius-rev.gitbooks.io/understanding-ecmascript-6-zh-ver/content/" target="_blank" rel="external">中译版</a>。</p>
<h2 id="异步编程的背景回溯"><a href="#异步编程的背景回溯" class="headerlink" title="异步编程的背景回溯"></a>异步编程的背景回溯</h2><h3 id="事件模型"><a href="#事件模型" class="headerlink" title="事件模型"></a>事件模型</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> button = <span class="built_in">document</span>.getElementById(<span class="string">"my-btn"</span>);</div><div class="line">button.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Clicked"</span>);</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p><strong>缺点：所有事件需要一次注册完毕，面对复杂需求不灵活</strong></p>
<h3 id="回调模式"><a href="#回调模式" class="headerlink" title="回调模式"></a>回调模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">readFile(<span class="string">"example.txt"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err, contents</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="keyword">throw</span> err;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(contents);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"Hi!"</span>);</div></pre></td></tr></table></figure>
<p><strong>缺点：回调地狱 callback hell</strong></p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">method1(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (err) &#123;</div><div class="line">        <span class="keyword">throw</span> err;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    method2(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (err) &#123;</div><div class="line">            <span class="keyword">throw</span> err;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        method3(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (err) &#123;</div><div class="line">                <span class="keyword">throw</span> err;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            method4(<span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (err) &#123;</div><div class="line">                    <span class="keyword">throw</span> err;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                method5(result);</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">        &#125;);</div><div class="line"></div><div class="line">    &#125;);</div><div class="line"></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="promise-的基础"><a href="#promise-的基础" class="headerlink" title="promise 的基础"></a>promise 的基础</h2><p>promise 是异步操作结果的占位符。函数可以返回一个 promise，而不用订阅一个事件或向函数传递回调参数。</p>
<h3 id="promise-的生命周期"><a href="#promise-的生命周期" class="headerlink" title="promise 的生命周期"></a>promise 的生命周期</h3><blockquote>
<p>每个 promise 的生命周期一开始都会处于短暂的挂起（pending）状态，表示异步操作仍未完成，即挂起的 promise 被认定是未定的（unsettled）。上例中的 promise 在 readFile() 返回结果之前就是处于挂起状态。一旦异步操作完成，promise 就被认为是已定（settled）的并处于以下的两种状态之一：</p>
<ol>
<li>fulfilled: promise 的异步操作已完成。</li>
<li>rejected: promise 的异步操作未完成，原因可能是发生了错误或其它理由。<br>所有的 promise 都包含 then() 方法并接受两个参数。第一个参数是 promise 为 fulfilled 状态下调用的函数，任何于异步操作有关的额外数据都会传给该它。第二个参数是 promise 为 rejected 状态下调用的函数，它会被传入任何与操作未完成有关的数据。</li>
</ol>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = readFile(<span class="string">"example.txt"</span>);</div><div class="line"></div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>) </span>&#123;</div><div class="line">    <span class="comment">// fulfillment</span></div><div class="line">    <span class="built_in">console</span>.log(contents);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="comment">// rejection</span></div><div class="line">    <span class="built_in">console</span>.error(err.message);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>) </span>&#123;</div><div class="line">    <span class="comment">// fulfillment</span></div><div class="line">    <span class="built_in">console</span>.log(contents);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="comment">// rejection</span></div><div class="line">    <span class="built_in">console</span>.error(err.message);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="comment">// rejection</span></div><div class="line">    <span class="built_in">console</span>.error(err.message);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 等效于:</span></div><div class="line"></div><div class="line">promise.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="comment">// rejection</span></div><div class="line">    <span class="built_in">console</span>.error(err.message);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="创建未定的-promise"><a href="#创建未定的-promise" class="headerlink" title="创建未定的 promise"></a>创建未定的 promise</h3><p>promise 由 Promise 构造函数创建。<br>该构造函数接收一个参数：包含初始化 promise 代码的执行（executor）函数。该执行函数接收 resolve() 和 reject() 两个参数。resolve() 函数会在执行函数成功运行后发出信号表示该 promise 已经可用，而 reject() 函数代表执行函数运行失败。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// Node.js example</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">"fs"</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filename</span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">// trigger the asynchronous operation</span></div><div class="line">        fs.readFile(filename, &#123; encoding: <span class="string">"utf8"</span> &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err, contents</span>) </span>&#123;</div><div class="line"></div><div class="line">            <span class="comment">// check for errors</span></div><div class="line">            <span class="keyword">if</span> (err) &#123;</div><div class="line">                reject(err);</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// the read succeeded</span></div><div class="line">            resolve(contents);</div><div class="line"></div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> promise = readFile(<span class="string">"example.txt"</span>);</div><div class="line"></div><div class="line"><span class="comment">// listen for both fulfillment and rejection</span></div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">contents</span>) </span>&#123;</div><div class="line">    <span class="comment">// fulfillment</span></div><div class="line">    <span class="built_in">console</span>.log(contents);</div><div class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</div><div class="line">    <span class="comment">// rejection</span></div><div class="line">    <span class="built_in">console</span>.error(err.message);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="创建已定-promise"><a href="#创建已定-promise" class="headerlink" title="创建已定 promise"></a>创建已定 promise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 使用 Promise.resolve()</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>);</div><div class="line"></div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);         <span class="comment">// 42</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 2. 使用 Promise.reject()</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.reject(<span class="number">42</span>);</div><div class="line"></div><div class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);         <span class="comment">// 42</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="Non-Promise-Thenables"><a href="#Non-Promise-Thenables" class="headerlink" title="Non-Promise Thenables"></a>Non-Promise Thenables</h3><p>一个不属于 promise 的 thenable 指的是包含 then() 方法的对象。该方法接收 resolve 和 reject 作为参数。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> thenable = &#123;</div><div class="line">    then(resolve, reject) &#123;</div><div class="line">        resolve(<span class="number">42</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</div><div class="line"></div><div class="line">p1.then(value =&gt; <span class="built_in">console</span>.log(value));</div></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> thenable = &#123;</div><div class="line">    then(resolve, reject) &#123;</div><div class="line">        reject(<span class="number">42</span>);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(thenable);</div><div class="line"></div><div class="line">p1.catch(value =&gt; <span class="built_in">console</span>.log(value));</div></pre></td></tr></table></figure>
<h3 id="执行错误"><a href="#执行错误" class="headerlink" title="执行错误"></a>执行错误</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Explosion!"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(error.message);     <span class="comment">// "Explosion!"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="promise-的全局-Rejection-处理"><a href="#promise-的全局-Rejection-处理" class="headerlink" title="promise 的全局 Rejection 处理"></a>promise 的全局 Rejection 处理</h2><blockquote>
<p>promise 最有争议的部分在于如果未提供 rejection 处理，那么 promise 中的错误会悄无声息的发生。有些人认为这是该规范中最大的败笔，因为它是 JavaScript 语言中唯一不会让错误自动浮出水面的场景。</p>
</blockquote>
<h3 id="Node-js-中的-rejection-处理"><a href="#Node-js-中的-rejection-处理" class="headerlink" title="Node.js 中的 rejection 处理"></a>Node.js 中的 rejection 处理</h3><blockquote>
<p>在 Node.js 中，process 对象上有两个事件和 promise 的 rejection 处理有关：</p>
<ul>
<li>unhandledRejection: 在一次事件轮询中，当一个 promise 处于 rejected 状态却没有 rejection 处理它，该事件会被触发。</li>
<li>rejectionHandled: 在一次事件轮询之后，如果存在 rejected 状态的 promise 并已被 rejection 处理过，该事件会被触发。</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. unhandledRejection</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> rejected;</div><div class="line"></div><div class="line">process.on(<span class="string">"unhandledRejection"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(reason.message);            <span class="comment">// "Explosion!"</span></div><div class="line">    <span class="built_in">console</span>.log(rejected === promise);      <span class="comment">// true</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">rejected = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Explosion!"</span>));</div><div class="line"></div><div class="line"><span class="comment">// 2. rejectionHandled</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> rejected;</div><div class="line"></div><div class="line">process.on(<span class="string">"rejectionHandled"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">promise</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(promise);              <span class="comment">// true</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">rejected = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Explosion!"</span>));</div><div class="line"></div><div class="line"><span class="comment">// 等待 rejection 处理的添加</span></div><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    rejected.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(value.message);     <span class="comment">// "Explosion!"</span></div><div class="line">    &#125;);</div><div class="line">&#125;, <span class="number">1000</span>);</div></pre></td></tr></table></figure>
<p>rejectionHandled 事件会在 rejection 处理被调用时触发。如果 rejection 处理直接添加到新创建的处于 rejected 状态的 promise 之后，那么该事件不会被触发。因为 rejected 状态的 promise 的创建和相关 rejection 处理的调用会发生在事件轮询的相同周期内。</p>
<p>简单的未处理 rejection 的追踪器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> possiblyUnhandledRejections = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"></div><div class="line"><span class="comment">// when a rejection is unhandled, add it to the map</span></div><div class="line">process.on(<span class="string">"unhandledRejection"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>) </span>&#123;</div><div class="line">    possiblyUnhandledRejections.set(promise, reason);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">process.on(<span class="string">"rejectionHandled"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">promise</span>) </span>&#123;</div><div class="line">    possiblyUnhandledRejections.delete(promise);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    possiblyUnhandledRejections.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(reason.message ? reason.message : reason);</div><div class="line"></div><div class="line">        <span class="comment">// do something to handle these rejections</span></div><div class="line">        handleRejection(promise, reason);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    possiblyUnhandledRejections.clear();</div><div class="line"></div><div class="line">&#125;, <span class="number">60000</span>);</div></pre></td></tr></table></figure>
<h3 id="浏览器中的-rejection-处理"><a href="#浏览器中的-rejection-处理" class="headerlink" title="浏览器中的 rejection 处理"></a>浏览器中的 rejection 处理</h3><blockquote>
<p>浏览器同样设置了两个事件以便查找未处理的 rejection 。这些事件由 window 对象触发并等效于 Node.js 的相关实现。</p>
<ul>
<li>unhandledrejection: 在一次事件轮询中，当一个 promise 处于 rejected 状态却没有 rejection 处理它，该事件会被触发。</li>
<li>rejectionhandled: 在一次事件轮询之后，如果存在 rejected 状态的 promise 并已被 rejection 处理过，该事件会被触发。<br>Node.js 的实现中，事件处理函数的参数是分别传入的，而浏览器中的事件处理函数参数接收一个包含以下属性的 event 对象：<br>type: 事件的名称（”unhandledrejection” 或 “rejectionhandled”）。<br>promise: 处于 rejected 状态的 promise 对象。<br>reason: promise 中的 rejection 值。<br>浏览器实现的另一处差异是 rejection 的值（reason）两个事件都可以使用。</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> rejected;</div><div class="line"></div><div class="line"><span class="built_in">window</span>.onunhandledrejection = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(event.type);                    <span class="comment">// "unhandledrejection"</span></div><div class="line">    <span class="built_in">console</span>.log(event.reason.message);          <span class="comment">// "Explosion!"</span></div><div class="line">    <span class="built_in">console</span>.log(rejected === event.promise);    <span class="comment">// true</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">window</span>.onrejectionhandled = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(event.type);                    <span class="comment">// "rejectionhandled"</span></div><div class="line">    <span class="built_in">console</span>.log(event.reason.message);          <span class="comment">// "Explosion!"</span></div><div class="line">    <span class="built_in">console</span>.log(rejected === event.promise);    <span class="comment">// true</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line">rejected = <span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Explosion!"</span>));</div></pre></td></tr></table></figure>
<p>浏览器中的简单的未处理 rejection 的追踪器：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> possiblyUnhandledRejections = <span class="keyword">new</span> <span class="built_in">Map</span>();</div><div class="line"></div><div class="line"><span class="comment">// when a rejection is unhandled, add it to the map</span></div><div class="line"><span class="built_in">window</span>.onunhandledrejection = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    possiblyUnhandledRejections.set(event.promise, event.reason);</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">window</span>.onrejectionhandled = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">    possiblyUnhandledRejections.delete(event.promise);</div><div class="line">&#125;;</div><div class="line"></div><div class="line">setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line"></div><div class="line">    possiblyUnhandledRejections.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">reason, promise</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(reason.message ? reason.message : reason);</div><div class="line"></div><div class="line">        <span class="comment">// do something to handle these rejections</span></div><div class="line">        handleRejection(promise, reason);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    possiblyUnhandledRejections.clear();</div><div class="line"></div><div class="line">&#125;, <span class="number">60000</span>);</div></pre></td></tr></table></figure>
<h2 id="promise-链（Chaining-Promises）"><a href="#promise-链（Chaining-Promises）" class="headerlink" title="promise 链（Chaining Promises）"></a>promise 链（Chaining Promises）</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"Finished"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 42</span></div><div class="line"><span class="comment">// Finished</span></div></pre></td></tr></table></figure>
<h3 id="捕获错误（Catching-Errors）"><a href="#捕获错误（Catching-Errors）" class="headerlink" title="捕获错误（Catching Errors）"></a>捕获错误（Catching Errors）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"Boom!"</span>);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(error.message);     <span class="comment">// "Boom!"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p><em>为了确保你能正确处理可能发生的错误，你总是需要在 promise 链的末尾添加一个 rejection 处理。</em></p>
<h3 id="promise-链中的返回值"><a href="#promise-链中的返回值" class="headerlink" title="promise 链中的返回值"></a>promise 链中的返回值</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);         <span class="comment">// "42"</span></div><div class="line">    <span class="keyword">return</span> value + <span class="number">1</span>;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);         <span class="comment">// "43"</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="Returning-Promises-in-Promise-Chains"><a href="#Returning-Promises-in-Promise-Chains" class="headerlink" title="Returning Promises in Promise Chains"></a>Returning Promises in Promise Chains</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">43</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 42</span></div><div class="line">    <span class="keyword">return</span> p2;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 43</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="Responding-to-Multiple-Promises"><a href="#Responding-to-Multiple-Promises" class="headerlink" title="Responding to Multiple Promises"></a>Responding to Multiple Promises</h2><h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><p><code>Promise.all()</code> 方法接收单个可迭代对象（如数组）作为参数，并返回一个 Promise 。这个可迭代对象的元素都是 Promise ，只有在它们都完成后，所返回的 Promise 才会被完成。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">43</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">44</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.all([p1, p2, p3]);</div><div class="line"></div><div class="line">p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(value));  <span class="comment">// true</span></div><div class="line">    <span class="built_in">console</span>.log(value[<span class="number">0</span>]);              <span class="comment">// 42</span></div><div class="line">    <span class="built_in">console</span>.log(value[<span class="number">1</span>]);              <span class="comment">// 43</span></div><div class="line">    <span class="built_in">console</span>.log(value[<span class="number">2</span>]);              <span class="comment">// 44</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>若传递给 Promise.all() 的任意 Promise 被拒绝了，那么方法所返回的 Promise 就会立刻被拒绝，而不必等待其他的 Promise 结束。</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    reject(<span class="number">43</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">44</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.all([p1, p2, p3]);</div><div class="line"></div><div class="line">p4.catch(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(value))   <span class="comment">// false</span></div><div class="line">    <span class="built_in">console</span>.log(value);                 <span class="comment">// 43</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race()"></a>Promise.race()</h3><p><code>Promise.race()</code> 提供了监视多个 Promise 的一个稍微不同的方法。此方法也接受一个包含需监视的 Promise 的可迭代对象，并返回一个新的 Promise ，但一旦来源 Promise 中有一个被解决，所返回的 Promise 就会立刻被解决。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="built_in">Promise</span>.resolve(<span class="number">42</span>);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">43</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">44</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.race([p1, p2, p3]);</div><div class="line"></div><div class="line">p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 42</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="继承-Promise"><a href="#继承-Promise" class="headerlink" title="继承 Promise"></a>继承 Promise</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPromise</span> <span class="keyword">extends</span> <span class="title">Promise</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 使用默认构造器</span></div><div class="line"></div><div class="line">    success(resolve, reject) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.then(resolve, reject);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    failure(reject) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.catch(reject);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> MyPromise(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">42</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.success(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);             <span class="comment">// 42</span></div><div class="line">&#125;).failure(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>来自译者及个人测试：</p>
<blockquote>
<p>若你传递一个 Promise 给 Promise.resolve() 或 Promise.reject() 方法，该 Promise 会不作修改原样返回。经过测试，在几大浏览器中都存在与上一句话不符的情况。</p>
</blockquote>
<hr>
<blockquote>
<ol>
<li>若传入的 Promise 为挂起态，则 <code>Promise.resolve()</code> 调用会将该 Promise 原样返回。此后，若决议原 Promise ，在 then() 中可以接收到原例中的参数 42 ；而若拒绝原 Promise ，则在 <code>catch()</code> 中可以接收到参数 42 。 但 <code>Promise.reject()</code> 调用则会对原先的 Promise 重新进行包装，对其使用 <code>catch()</code> 可以捕捉到错误，处理函数中的 value 参数不会是数值 42 ，而是原先处于挂起态的 Promise 。</li>
<li>若传入的 Promise 为完成态，则 <code>Promise.resolve()</code> 调用会将该 Promise 原样返回，在 <code>then()</code> 中可以接收到原例中的参数 42 。 但 <code>Promise.reject()</code> 调用则会对原先的 Promise 重新进行包装，对其使用 <code>catch()</code> 可以捕捉到错误，处理函数中的 value 参数不会是数值 42 ，而是原先处于完成态的 Promise 。</li>
<li>若传入的 Promise 为拒绝态，则 <code>Promise.reject()</code> 调用会将该 Promise 原样返回，在 <code>catch()</code> 中可以接收到参数 42 。 但 <code>Promise.resolve()</code> 调用则会对原先的 Promise 重新进行包装，对其使用 <code>then()</code> 可以进行完成处理，处理函数中的 value 参数不是 42 ，而是原先处于拒绝态的 Promise 。也就是说此时的情况与上一种情况相反。</li>
</ol>
<p>总结：对挂起态或完成态的 Promise 使用 <code>Promise.resolve()</code> 没问题，会返回原 Promise ；对拒绝态的 Promise 使用 <code>Promise.reject()</code> 也没问题。而除此之外的情况全都会在原 Promise 上包装出一个新的 Promise 。</p>
</blockquote>


    
    
    
	  <div class="tags">
      <a class="tag-link" href="/tags/ES6/">ES6</a><a class="tag-link" href="/tags/JavaScript/">JavaScript</a><a class="tag-link" href="/tags/Promise/">Promise</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/2017/02/03/JavaScript/使用github和pm2部署node服务/">
      使用 pm2 部署 node 服务
    </a>
  </h2>
  
  <time>
    2月 3, 2017
  </time>
  <section class="content">
	  <h2 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h2><p>前段时间接的项目现在进入了后续维护阶段，正式环境已经正常运行了。现在需要部署到测试的服务器上，以便后续的修改和维护，所以就想用 pm2 来完成部署。</p>

    
	  <div class="readmore">
      <a href="/2017/02/03/JavaScript/使用github和pm2部署node服务/">Read More</a>
    </div>
    
    
    
	  <div class="tags">
      <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/2017/01/19/转载/【转载】转载我宇的一篇文章/">
      【转载】转载我宇的一篇文章
    </a>
  </h2>
  
  <time>
    1月 19, 2017
  </time>
  <section class="content">
	  <blockquote><p>转载罐罐的一篇文章。关于 JS 设计模式的。这本书我也借了，但是最近天天加班，没有时间看。先转载这篇文章，留个坑。</p>
<footer><strong>GaryChang 一个帅气的男人</strong><cite><a href="http://garychang.cn/2017/01/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">js 设计模式</a></cite></footer></blockquote>


    
    
    
	  <div class="tags">
      <a class="tag-link" href="/tags/学习整理/">学习整理</a><a class="tag-link" href="/tags/转载/">转载</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/2017/01/13/总结/2016年总结/">
      迟到的 2016 年的总结
    </a>
  </h2>
  
  <time>
    1月 13, 2017
  </time>
  <section class="content">
	  <p>其实 2017 年已经开始了快十几天了，我才动手写 2016 年的总结。前段时间一直在复习考试，所以总结一直被搁浅。现在考完试终于可以好好梳理一下自己过去一年了。</p>
<h2 id="毫无建树的上半年"><a href="#毫无建树的上半年" class="headerlink" title="毫无建树的上半年"></a>毫无建树的上半年</h2><p>这个标题好像很消极，但事实上它很好地概括了我 2016 年上半年的经历。说实话，关于我上半年的经历、收获，我几乎回想不起来了，从过完年回到学校，我基本上是在找实习、投简历和面试中度过的。感觉是浑浑厄厄的半年，其实很遗憾又懊悔，在大学的大多数的时光里，几乎都这样浑浑厄厄的过去了。到现在接近毕业，实在是懊恼无比。</p>

    
	  <div class="readmore">
      <a href="/2017/01/13/总结/2016年总结/">Read More</a>
    </div>
    
    
    
	  <div class="tags">
      <a class="tag-link" href="/tags/学习整理/">学习整理</a><a class="tag-link" href="/tags/总结/">总结</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/2016/10/14/JS高程学习/JS-learn-8/">
      JS 高程学习 8：Object 类型
    </a>
  </h2>
  
  <time>
    10月 14, 2016
  </time>
  <section class="content">
	  <p>终于慢慢地刷到第五章引用类型。这真的是一本很好的书，值得慢慢看。引用类型的值（对象）是引用类型的一个实例，对象是对某个特定引用类型的实例。今天来看一下 Object 类型。</p>
<h2 id="如何创建-Object-实例"><a href="#如何创建-Object-实例" class="headerlink" title="如何创建 Object 实例"></a>如何创建 Object 实例</h2><p>看代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 使用 new 操作符后跟 Object 构造函数</span></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</div><div class="line">person.name = <span class="string">"Jayden"</span>;</div><div class="line">person.age = <span class="number">21</span>;</div><div class="line"></div><div class="line"><span class="comment">// 使用对象字面量方法 推荐使用</span></div><div class="line"><span class="keyword">var</span> person = &#123;</div><div class="line">  name : <span class="string">"Jayden"</span>,</div><div class="line">  age: <span class="number">21</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 这里要注意一下语法，对象的最后一个属性后面不需要添加逗号，</span></div><div class="line"><span class="comment">// 在 IE7 以及更早版本的 Opera 中会引发错误。</span></div><div class="line"></div><div class="line"><span class="comment">// 在使用对象字面量方法的时候，如果留空，则定义只包含默认属性和方法的对象</span></div><div class="line"><span class="keyword">var</span> obj = &#123;&#125;; <span class="comment">// 与 new Object() 相同</span></div></pre></td></tr></table></figure>

    
	  <div class="readmore">
      <a href="/2016/10/14/JS高程学习/JS-learn-8/">Read More</a>
    </div>
    
    
    
	  <div class="tags">
      <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/2016/10/09/JavaScript/数组的优雅降维/">
      数组的优雅降维
    </a>
  </h2>
  
  <time>
    10月 9, 2016
  </time>
  <section class="content">
	  <blockquote>
<p>这个月开始在新的公司开始实习，昨天是第一天～然后技术负责人让我先完成一些基础练习。回顾基础知识其实学到很多。这段时间会陆续记录下来。</p>
</blockquote>
<h2 id="问题是什么"><a href="#问题是什么" class="headerlink" title="问题是什么"></a>问题是什么</h2><p>这次要记录的一个问题是数组的降维。这是一个蛮有趣的问题，在解决问题的过程中学到了挺多有趣的有用的基础知识，在这里除了给出自己的答案之外，还会记录一下自己搜索到的解决方法。先来看一下题目：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, [<span class="number">2</span>, [<span class="number">3</span>, <span class="number">4</span>]], <span class="number">5</span>, [<span class="number">6</span>]];</div><div class="line"></div><div class="line"><span class="comment">/**</div><div class="line"> * 把多维数组转换为一维数组。</div><div class="line"> *</div><div class="line"> * 比如[1, [2, [3, 4]], 5, [6]]在flatten之后的结果应该是[1,2,3,4,5,6]</div><div class="line"> *</div><div class="line"> * @param array 要flatten的数组。</div><div class="line"> * @returns Array flatten之后的一维数组。</div><div class="line"> */</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> flattenMd = <span class="function"><span class="keyword">function</span>(<span class="params">array</span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(flattenMd(a)); <span class="comment">// [1,2,3,4,5,6]</span></div></pre></td></tr></table></figure>

    
	  <div class="readmore">
      <a href="/2016/10/09/JavaScript/数组的优雅降维/">Read More</a>
    </div>
    
    
    
	  <div class="tags">
      <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>
	  </div>
    

  </section>
</article>
  
    <article class="post ">

  
  <h2 class="title">
    <a href="/2016/10/07/JS高程学习/JS高程学习7_基本类型和引用类型/">
      JS 高程学习 7：关于基本类型和引用类型的介绍
    </a>
  </h2>
  
  <time>
    10月 7, 2016
  </time>
  <section class="content">
	  <h2 id="基本类型和引用类型的值"><a href="#基本类型和引用类型的值" class="headerlink" title="基本类型和引用类型的值"></a>基本类型和引用类型的值</h2><p>ECMAScript 变量可能包含两种不同数据类型的值：基本类型值和引用类型值。注意引用类型的值是保存在内存中的对象。而JavaScript 是不允许直接访问内存中的位置，因此在操作对象的时候，实际上是操作对象的引用而不是实际的对象。但是在为对象添加属性的时候，操作的是实际的对象。</p>
<h2 id="动态的属性"><a href="#动态的属性" class="headerlink" title="动态的属性"></a>动态的属性</h2><ol>
<li>对于引用类型的值，我们可以为其添加属性和方法，也可以改变或删除。</li>
<li>但是不能给基本类型的值添加属性。</li>
</ol>

    
	  <div class="readmore">
      <a href="/2016/10/07/JS高程学习/JS高程学习7_基本类型和引用类型/">Read More</a>
    </div>
    
    
    
	  <div class="tags">
      <a class="tag-link" href="/tags/JavaScript/">JavaScript</a>
	  </div>
    

  </section>
</article>
  
</section>


  <nav id="page-nav">
    
    
    <a class="next" rel="next" href="/page/2/">
      <span class="text">Next</span>
      <span class="icon icon-chevron-right"></span>
    </a>
    
  </nav>
  

      <script>setLoadingBarProgress(60);</script>
    </main>
    
    <footer id="footer" class="clearfix">
  
  

	<div class="social-wrapper">
  	
      
        <a href="https://github.com/JxJayden" class="social github"
          target="_blank" rel="external">
          <span class="icon icon-github"></span>
        </a>
      
    
  </div>
  
  <div>Theme <span class="codename">Typescript</span> designed by <a href="http://rakugaki.me/" target="_blank">Art Chen</a>.</div>
  <div>&copy; <a href="/">代码与胡说</a></div>
  
</footer>


    <script>setLoadingBarProgress(80);</script>
    
  </div>

  


<script>
  var duoshuoQuery = {short_name:"jxjayden"};
  (function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
     || document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script>


<script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
<script>window.jQuery || document.write('<script src="/js/jquery.min.js"><\/script>')</script>

<script src="/js/jquery.fitvids.js"></script>
<script>
	var GOOGLE_CUSTOM_SEARCH_API_KEY = "";
	var GOOGLE_CUSTOM_SEARCH_ENGINE_ID = "";
	var ALGOLIA_API_KEY = "";
	var ALGOLIA_APP_ID = "";
	var ALGOLIA_INDEX_NAME = "";
  var AZURE_SERVICE_NAME = "";
  var AZURE_INDEX_NAME = "";
  var AZURE_QUERY_KEY = "";
  var BAIDU_API_ID = "";
  var SEARCH_SERVICE = "google";
</script>
<script src="/js/search.js"></script>
<script src="/js/app.js"></script>


  <script>setLoadingBarProgress(100);</script>
  
</body>
</html>
